/**
 * Parser to convert tokens emitted by the lexer into semantic groups.
 *
 * @author Jonathan Uhler
 */


#ifndef _ASSEMBLER_PARSER_H_
#define _ASSEMBLER_PARSER_H_


#include "assembler/lexer.h"
#include "architecture/isa.h"
#include "structures/list.h"
#include <stdint.h>
#include <stdio.h>


/**
 * The possible semantic group types.
 */
enum parser_group_type {
    /** A group of tokens that form an instruction (any Format/type, including pseudo). */
    PARSER_GROUP_INSTRUCTION,
    /** A group of tokens that define a label. */
    PARSER_GROUP_LABEL,
    /** A group of tokens that define a directive. */
    PARSER_GROUP_DIRECTIVE,
    /** End of file; no semantic group was generated. */
    PARSER_GROUP_EOF
};


/**
 * Semantic group for an instruction.
 */
struct parser_group_instruction {
    /** Opcode of the instruction. */
    enum isa_opcode opcode;
    /** Destination register. */
    enum isa_register dest;
    /** Source1 register. */
    enum isa_register source1;
    /** Source2 register. */
    enum isa_register source2;
    /** Text of label used in the instruction. */
    char label[LEXER_TOKEN_MAX_LENGTH + 1];
    /** Numeric immediate value used in the instruction. */
    uint16_t immediate;
    /** Binary value of the instruction, set by the encoder. */
    uint32_t binary;
};


/**
 * Semantic group for a label.
 */
struct parser_group_label {
    /** Text of the label. */
    char label[LEXER_TOKEN_MAX_LENGTH + 1];
    /** Numeric immediate value of the label. */
    uint32_t immediate;
};


/**
 * Types of directives recognized by the parser.
 */
enum parser_directive_type {
    /** .loc directive to set parser pc location. */
    PARSER_DIRECTIVE_LOC,
    /** .half directive to store a halfword. */
    PARSER_DIRECTIVE_HALF,
    /** .include directive handled at parse-time (not emitted to groups). */
    PARSER_DIRECTIVE_INCLUDE
};


/**
 * Semantic group for a location directive.
 */
struct parser_directive_loc {
    /** The number of pad bytes needed to reach the .loc location. */
    uint16_t num_pad_bytes;
};


/**
 * Semantic group for a half directive.
 */
struct parser_directive_half {
    /** The value of the halfword. */
    uint16_t element;
};


/**
 * Semantic group for an include directive (parser-level).
 *
 * This is used internally in the parser; include directives are expanded into tokens and do not
 * become semantic groups in the output list.
 */
struct parser_directive_include {
    /** Path to the file to be included (null-terminated). */
    char path[LEXER_TOKEN_MAX_LENGTH + 1];
};


/**
 * Semantic group for any type of directive.
 */
struct parser_group_directive {
    /** The type of the directive. */
    enum parser_directive_type type;
    union {
        /** .loc view of the directive group. */
        struct parser_directive_loc loc;
        /** .half view of the directive group. */
        struct parser_directive_half half;
        /** .include view of the directive group. */
        struct parser_directive_include include;
    };
};


/**
 * A structure representing a single group of tokens that form a single semantic unit.
 */
struct parser_group {
    /** The type of the group, used to determine which other members are usable. */
    enum parser_group_type type;
    union {
        /** Instruction view of the semantic group. */
        struct parser_group_instruction instruction;
        /** Label view of the semantic group. */
        struct parser_group_label label;
        /** Directive view of the semantic group. */
        struct parser_group_directive directive;
    };
};


/**
 * The status of parser API functions.
 */
enum parser_status {
    /** The parser operation was successful. */
    PARSER_STATUS_SUCCESS = 0,
    /** The parser reached the end of the file. */
    PARSER_STATUS_EOF,
    /** The parser API function was called with an invalid argument. */
    PARSER_STATUS_INVALID_ARGUMENT,
    /** The parser encountered a semantic error during parsing. */
    PARSER_STATUS_SEMANTIC_ERROR
};


/**
 * Parses all semantic groups from a list of tokens generated by the lexer, returning them in
 * chronological order.
 *
 * Parsing will proceed until the entire token stream is read (EOF) or an error is encountered. The
 * parser does not need to be called as a generator to get further semantic groups after a
 * successful call.
 *
 * @param tokens[inout]  The list of tokens to parse. Tokens will be popped from this list.
 * @param groups[out]    A pointer to return a list of processed semantic groups. It is the caller's
 *                       responsibility to free this list with the structures/list API. The groups
 *                       must be freed with the list_default_node_free_callback to free the node
 *                       data as well.
 *
 * @return The status of the parser call. If SUCCESS, the parser proceeded all tokens and stored
 *         the associated semantic groups in the list output pointer (in a new list allocated by the
 *         parser). If failure, the parser encountered an error and should not be called again on
 *         the same token list. If a non-success status is returned, the caller does not need to
 *         free the groups list.
 */
enum parser_status parser_parse_tokens(struct list *tokens, struct list **groups);


#endif  // _ASSEMBLER_PARSER_H_
